### 防抖

定义：当持续触发事件，一定时间内没有再触发事件，时间的处理函数才会执行一次。如果设定的延时时间到来之前，又一次触发了事件，那就重新开始延时。
由定义进一步分析，可以得出的是，防抖在进行时会有两种情况：

- 触发事件在一定时间内没有触发，那后续的处理函数正常执行
- 触发事件在一定时间内被出发了，那之前的定时器需要被清零，然后重新设立一个触发事件的计时器。

第一个分支很好理解，但是在第二个分支下，触发器触发后，之前的定时器就需要被清除掉，然后再设立一个新的触发器。这就很容易联想到闭包了。

```js
function trigger(fun, delay) {
  let timer;
  return function (args) {
    clearInterval(timer);
    timer = setTimeout(() => {
      fun(args);
    }, delay);
  };
}
```

上面是运用闭包实现防抖的一个经典应用，trigger 返回了一个函数，这个函数引用了 trigger 中的 timer，这就形成了闭包。闭包缓存了上一次的 timer，所以在 trigger 返回的函数（触发器）被再次调用的时候，闭包中的 timer 就被清除掉，然后重新赋值。由于 timer 是被定义在 trigger 中，所以 timer 会被继续缓存，继续进入到下一个周期里。

防抖的经典应用：

- 监听 input 的输入时，等用户输入完成后（指定时间内不再触发输入事件），再执行下一部的代码，防止用户一边输入一边执行。（搜索时节省性能，防止因为异步请求造成错误结果）
- echarts 改变浏览器宽度时需要重新渲染，希望等改变完宽度后再响应进行重新渲染

### 节流

定义：当持续触发事件的时候，保证一段时间内，只调用一次事件处理函数

同样我们分析一下情况：
当触发事件被触发后，响应函数开始执行，同时定时器开始运行，之后进行了第二次触发

- 如果第二次触发是在定时器时间内，那么就不理睬，定时器继续走。
- 如果第二次触发是在定时器时间结束后，那响应函数就需要被执行，同时定时器也需要被清空掉，并重新开始计时

```js
function trigger(fun, wait) {
  let timer;
  return function (args) {
    if (!timer) {
      fun(args);
      timer = setTimeout(() => {
        timer = null;
      }, wait);
    }
  };
}
```

节流的经典应用：

- 防止提交表单的时候多次点击按钮
<!-- - 图片懒加载（onScroll 时加载图片，对 onScroll 使用节流） -->
