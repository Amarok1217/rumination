### 闭包

JavaScript 的闭包是一个特色。官方解释是：闭包是一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。

直接举个例子

```js
var count = 10; //全局作用域 标记为flag1
function add() {
  var count = 0; //函数全局作用域 标记为flag2
  return function () {
    count += 1; //函数的内部作用域
    alert(count);
  };
}
var s = add();
s(); //输出1
s(); //输出2
```

先来简单分析一下，add()的返回值是一个函数，首先第一次调用 s()的时候，是执行 add()的返回的函数，也就是下面这个函数：

```js
function(){
    count+=1;//函数的内部作用域
    alert(count);
}
```

也就是将 count+1，在输出，那 count 是从哪儿来的的呢，根据作用域链的规则，底层作用域没有声明的变量，会向上一级找，找到就返回，没找到就一直找，直到 window 的变量，没有就返回 undefined。这里明显 count 是函数内部的 flag2 的那个 count。如果没有 flag2，就会继续向上找到 flag1 的 count。

这里有一个点需要注意，那就是 s()执行的实际上是下面这个函数

```js
function(){
        count+=1;//函数的内部作用域
        alert(count);
    }
```

也就是说 add()，只被执行了一次。然后执行两次 s()，那 count 的值就是只声明了一次。

var s=add()，函数 add 只在这里执行了一次。后面执行的都是 s()，那第二次的 count 的值是从哪儿来的？

没错它还是第一次执行 add 时，留下来的那个变量。
（这怎么可能，函数变量执行完就会被释放啊，为什么还在？这里就是一个垃圾回收机制的引用计数问题）
“如果一个变量的引用不为 0，那么他不会被垃圾回收机制回收，引用，就是被调用”。
由于再次执行 s()的时候，再次引用了第一次 add()产生的变量 count ，所以 count 没有被释放，第一次 s(),count 的值为 1,第二次执行 s()，count 的值再加 1，自然就是 2 了。

让我们返回来再看看，根据以上所说，如果执行两次 add() ，那就应该输出 都是 1，来改一下这个函数。

```js
function add() {
  var count = 0; //函数全局作用域
  return function () {
    count += 1; //函数的内部作用域
    alert(count);
  };
}
add()(); //输出1
add()(); //输出1
```

果真如此。输出的两次都是 1.

另外，我觉得阮一峰说的闭包也是很简洁的：“我的理解是，闭包就是能够读取其他函数内部变量的函数。”

### 变量的作用域

变量的作用域无非就是两种：全局变量和局部变量。

Javascript 语言的特殊之处，就在于函数内部可以直接读取全局变量。“链式作用域”结构（chain scope）中，子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。

如果 f1 函数中定义了 f2，f2 中引用了 f1 的局部变量。正常情况下外界是无法获取到 f1 的局部变量的，此时只要把 f2 作为 f1 的返回值返回出去，就可以实现在 f1 的外部调用 f1 的局部变量了。

### 闭包的用途

由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。
