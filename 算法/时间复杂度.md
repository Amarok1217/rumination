## 基本定义

算法的时间复杂度，用来度量算法的运行时间，记作: T(n) = O(f(n))。它表示随着 输入大小 n 的增大，算法执行需要的时间的增长速度可以用 f(n) 来描述。

时间复杂度的概念比较抽象，它反映的其实是一个算法的复杂程度/执行效率。一个时间复杂度高的算法，就意味着运算次数多、算法设计复杂。

## 计算方式

在实际使用中，我们用 O(n)来表示时间复杂度，而 O(n)则是用 T(n)，即**总运算次数和输入的 n 的函数**来推导出。

## 基本法则

单说概念会比较抽象，看几个基本准则

1. 我们知道常数项对函数的增长速度影响并不大，所以当 T(n) = c，c 为一个常数的时候，我们说这个算法的时间复杂度为 O(1)；如果 T(n) 不等于一个常数项时，直接将常数项省略。
2. 我们知道高次项对于函数的增长速度的影响是最大的。n^3 的增长速度是远超 n^2 的，同时 n^2 的增长速度是远超 n 的。 同时因为要求的精度不高，所以我们直接忽略低此项。
   比如
   T(n) = n^3 + n^2 + 29，此时时间复杂度为 O(n^3)。
3. 因为函数的阶数对函数的增长速度的影响是最显著的，所以我们忽略与最高阶相乘的常数
   比如
   T(n) = 3n^3，此时时间复杂度为 O(n^3)。

**如果一个算法的执行次数是 T(n)，那么只保留最高次项，同时忽略最高项的系数后得到函数 f(n)，此时算法的时间复杂度就是 O(f(n))。**

## 推导法则

1. 对于一个循环，假设循环体的时间复杂度为 O(n)，循环次数为 m，则这个循环的时间复杂度为 O(n×m)。

```js
function test(n) {
  for (let i = 0; i < n; i++) {
    // 循环次数为n
    console.log(n); // 循环体时间复杂度为O(1)
  }
}
// 因此，此算法复杂度为O(n*1)，即O(n)
```

2. 对于多个循环，假设循环体的时间复杂度为 O(n)，各个循环的循环次数分别是 a, b, c...，则这个循环的时间复杂度为 O(n×a×b×c...)。分析的时候应该**由里向外**分析这些循环。

```js
function test(n) {
  for (let i = 0; i < n; i++) {
    // 循环次数为 n
    for (let j = 0; j < n; j++) {
      // 循环次数为 n
      console.log('hello'); // 循环体时间复杂度为 O(1)
    }
  }
}
// 因此，此算法时间复杂度为O(n*n*1),即O(n^2)
```

3. 对于**顺序执行**的语句或者算法，总的时间复杂度等于其中最大的时间复杂度。

```js
function test(n) {
  for (let i = 0; i < n; i++) {
    console.log(n);
  }
  //   这部分时间复杂度为O(n*1)，即O(n)
  for (let i = 0; i < n; i++) {
    // 循环次数为 n
    for (let j = 0; j < n; j++) {
      console.log('hello');
    }
  }
  //   z这部分时间复杂度为O(n*n*1),即O(n^2)
}
// 因此，此算法时间复杂度取最大值，即O(n^2)
```

4. 对于**条件判断**语句，总的时间复杂度等于其中**时间复杂度最大的路径**的时间复杂度。

```js
function test(n) {
    if(n<5>){
        for (let i = 0; i < n; i++) {
          console.log(n);
        }
        //   这部分时间复杂度为O(n*1)，即O(n)
    }else{
        for (let i = 0; i < n; i++) {
          // 循环次数为 n
          for (let j = 0; j < n; j++) {
            console.log('hello');
          }
        }
        //   z这部分时间复杂度为O(n*n*1),即O(n^2)
    }
}
// 因此，此算法时间复杂度取最大路径，即O(n^2)
```
